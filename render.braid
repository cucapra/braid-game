extern rt.projection: Mat4;
extern rt.viewMatrix: Mat4;
var projection = rt.projection;
var viewMatrix = rt.viewMatrix;

# Teapot model.
var t_mesh = load_obj("teapot.obj");
var t_position = mesh_positions(t_mesh);
var t_normal = mesh_normals(t_mesh);
var t_indices = mesh_indices(t_mesh);
var t_size = mesh_size(t_mesh);
var texcoord = mesh_texcoords(t_mesh);


# Load skyBox
var skyBoxMesh = load_obj("skyBox.obj");
var skyBoxPosition = mesh_positions(skyBoxMesh);
var skyBoxIndices = mesh_indices(skyBoxMesh);
var skyBoxSize = mesh_size(skyBoxMesh);
var skyTex = cubeTexture(load_image("posx.jpg"), load_image("negx.jpg"), 
load_image("posy.jpg"), load_image("negy.jpg"), load_image("posz.jpg"), load_image("negz.jpg"));

# phong shading, depends on L, V, N, R, diffuseColor, lightColor
def phong_shading(L: Float3, V: Float3, N: Float3, Rsq: Float, 
                  diffuseColor: Float3, lightColor: Float3, p: Float) (
  var H = normalize(L + V);
  # calculate diffuse term
  var Idiff = diffuseColor * max(dot(N, L), 0.0);
  # calculate specular term
  var Ispec = vec3(1.0, 1.0, 1.0) * pow(max(dot(N, H), 0.0), p);
  lightColor * (Idiff + Ispec) / Rsq;
);



# Load a texture from an image.
var tex = texture(load_image("wood1.png"));
# The parameters for the Phong shader.
var roughness = 0.1;
var NUM_LIGHTS = 1;
var lightColors = array(vec3(1.0, 0.9, 0.8));
var lightPositions = array(vec3(20.0, 10.0, -10.0));
var exposure = 500.0;
def simple_shader(pos: Float3 Buffer, norm: Float3 Buffer, model: Mat4, uv: Float2 Buffer, lightPos: Float3, lightColor: Float3) (
    var normalMatrix = mat4();
    mat4.invert(normalMatrix, viewMatrix * model);
    mat4.transpose(normalMatrix, normalMatrix);    
    vertex glsl<
    gl_Position = projection * viewMatrix * model * vec4(pos, 1.0);
    fragment glsl<
      var vPosition = viewMatrix * model * vec4(pos, 1.0);
      var vNormal = vec3(normalMatrix * vec4(norm, 0.0));
      var N = normalize(vNormal);
      var V = normalize(-vec3(vPosition));
      var lightpos = vec3(viewMatrix * vec4(lightPos, 1.0));
      var vr = lightpos - vec3(vPosition);
      var L = normalize(lightpos - vec3(vPosition)); 
      var finalC = phong_shading(L,V,N,dot(vr,vr),vec3(texture2D(tex, uv)),
                                  lightColor, 1.0/roughness);
      gl_FragColor = vec4(finalC*exposure, 1.0); 
    >
    >;
);
def skybox_shader(pos: Float3 Buffer, model: Mat4) (
    var mvInv = mat4();
    mat4.invert(mvInv, viewMatrix*model);
    vertex glsl<
        gl_Position = projection * viewMatrix * model * vec4(pos, 1.0);
        fragment glsl<
          var eye = vec3(mvInv * vec4(0.0, 0.0, 0.0, 1.0));
          # Change vector from right-hand coordinate system to left-hand coordinate system, which is a webgl convention
          gl_FragColor = textureCube(skyTex, (pos - eye) * vec3(-1.0, 1.0, 1.0));
        >
    >;
);

var t_model = mat4.create();
mat4.scale(t_model, t_model, vec3(0.1, 0.1, 0.1));
render js<
  simple_shader(t_position, t_normal, t_model, texcoord, get(lightPositions, 0), get(lightColors,0));
  draw_mesh(t_indices, t_size);
  skybox_shader(skyBoxPosition, mat4.create());
  draw_mesh(skyBoxIndices, skyBoxSize);
>

