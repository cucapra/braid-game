extern camera.update : String -> Void = "rt.camera.updateCam";
extern camera.getViewMatrix : Mat4 -> Void = "rt.camera.getViewM";
extern camera.getProjMatrix : Mat4 Float Float -> Void = "rt.camera.getProjM";
extern camera.simulateControl : Float3 String -> Void = "rt.camera.simCtrl";
extern control.isOn : String -> Bool = "rt.control.isOn";
extern control.control_names : String Array = "rt.control.control_names";
extern print : Any -> Void = "console.log";
extern vec4.transformMat4 : Float4 Float4 Mat4 -> Void;
extern rt.drawWidth: Float;
extern rt.drawHeight: Float;

var get_transform_matrix = fun trans: Transform -> (
  var t = get_transform_translation(trans);
  var rx = get_transform_rotationX(trans);
  var ry = get_transform_rotationY(trans);
  var rz = get_transform_rotationZ(trans);
  var s = get_transform_scale(trans);
  t*rx*ry*rz*s;
);

#create room mesh

var room_mesh = load_obj("room.obj");
var room_position = mesh_positions(room_mesh);
var room_normal = mesh_normals(room_mesh);
var room_indices = mesh_indices(room_mesh);
var room_size = mesh_size(room_mesh);
var room_texcoord = mesh_texcoords(room_mesh);

# # Teapot model.
# var t_mesh = load_obj("teapot.obj");
# var t_position = mesh_positions(t_mesh);
# var t_normal = mesh_normals(t_mesh);
# var t_indices = mesh_indices(t_mesh);
# var t_size = mesh_size(t_mesh);
# var texcoord = mesh_texcoords(t_mesh);
#
#
# # Load skyBox
# var skyBoxMesh = load_obj("skyBox.obj");
# var skyBoxPosition = mesh_positions(skyBoxMesh);
# var skyBoxIndices = mesh_indices(skyBoxMesh);
# var skyBoxSize = mesh_size(skyBoxMesh);
# var skyTex = cubeTexture(load_image("posx.jpg"), load_image("negx.jpg"),
# load_image("posy.jpg"), load_image("negy.jpg"), load_image("posz.jpg"), load_image("negz.jpg"));
# var roomSize = 100.0;

# Load a texture from an image.
var room_tex = texture(load_image("wood1.png"));




# The parameters for the Phong shader.
var roughness = 0.1;
var NUM_LIGHTS = 1;
# var lightColors = array(vec3(1.0, 0.9, 0.8));
# var lightPositions = array(vec3(20.0, 10.0, -10.0), vec3(50.0, 10.0, -50.0));
var exposure = 500.0;
var projection = mat4.create();
var viewMatrix = mat4.create();
def simple_shader(pos: Float3 Buffer, norm: Float3 Buffer, model: Mat4, uv: Float2 Buffer,
  lightPos: Float3, lightColor: Float3, tex:Texture, useTex:Float, color:Float3) (
    var normalMatrix = mat4();
    mat4.invert(normalMatrix, viewMatrix * model);
    mat4.transpose(normalMatrix, normalMatrix);
    vertex glsl<
    gl_Position = projection * viewMatrix * model * vec4(pos, 1.0);
    fragment glsl<
      var vPosition = viewMatrix * model * vec4(pos, 1.0);
      var vNormal = vec3(normalMatrix * vec4(norm, 0.0));
      var N = normalize(vNormal);
      var V = normalize(-vec3(vPosition));
      var lightpos = vec3(viewMatrix * vec4(lightPos, 1.0));
      var vr = lightpos - vec3(vPosition);
      var L = normalize(lightpos - vec3(vPosition));
      var H = normalize(L + V);
      # calculate diffuse term
      var Idiff = vec4(1.0,1.0,1.0,0.0);
      if (useTex >= 1.0) (
        Idiff = texture2D(tex, uv) * max(dot(N, L), 0.0);
      )(
        Idiff = vec4(color, 0.0) * max(dot(N, L), 0.0);
      );
      # calculate specular term
      var Ispec = vec4(1.0, 1.0, 1.0, 0.0) * pow(max(dot(N, H), 0.0), 1.0 / roughness);
      var finalColor = vec4(lightColor, 0.0) * (Idiff + Ispec) / dot(vr, vr);
      gl_FragColor = vec4(vec3(finalColor*exposure), 1.0);
    >
    >;
);
# def skybox_shader(pos: Float3 Buffer, model: Mat4) (
#     var mvInv = mat4();
#     mat4.invert(mvInv, viewMatrix*model);
#     vertex glsl<
#         gl_Position = projection * viewMatrix * model * vec4(pos, 1.0);
#         fragment glsl<
#           var weye = vec3(mvInv * vec4(0.0, 0.0, 0.0, 1.0));
#           # Change vector from right-hand coordinate system to left-hand coordinate system, which is a webgl convention
#           gl_FragColor = textureCube(skyTex, (pos-weye) * vec3(-1.0, 1.0, 1.0));
#         >
#     >;
# );

# var t_model = mat4.create();
# mat4.scale(t_model, t_model, vec3(0.5, 0.5, 0.5));
# mat4.translate(t_model, t_model, vec3(50.0, 20.0, -50.0));



# so that else branch does something
def void_fun (x: Float) (
  x = x;
);

var get_light_pos_color = fun light: Light -> (
  var light_pos = get_light_position(light);
  var light_intensity = get_light_intensity(light);
  var light_color = get_light_color(light);
  light_color = light_color * light_intensity;
  light_pos, light_color
);

var draw_room = fun lights: (Light Array) -> (
  var light = get(lights, 0);
  var l = get_light_pos_color(light);
  var size = get_room_size(get_room(get_current_room()));
  var scale = mat4.create();
  mat4.scale(scale, scale, size);
  simple_shader(room_position, room_normal, scale, room_texcoord,
    (l).0, (l).1, room_tex, 1.0, vec3(0.0,0.0,0.0));
);

def draw_object(obj_pos: Vec3, obj_transform: Transform, obj_mesh: Mesh,
  obj_tex: Texture, obj_shader: String, lights: (Light Array)) (
    var light = get(lights, 0);
    var l = get_light_pos_color(light);
    var obj_t = mat4.create();
    mat4.translate(obj_t, obj_t, obj_pos);
    var trans = get_transform_matrix(obj_transform);
    obj_t = obj_t * trans;
    var obj_position = mesh_positions(obj_mesh);
    var obj_normal = mesh_normals(obj_mesh);
    var obj_indices = mesh_indices(obj_mesh);
    var obj_size = mesh_size(obj_mesh);
    var obj_texcoord = mesh_texcoords(obj_mesh);
    simple_shader(obj_position, obj_normal, obj_t, obj_texcoord,
      (l).0, (l).1, obj_tex, 1.0, vec3(0.0,0.0,0.0));
);

var draw_objects = fun lights: (Light Array) -> (
  var room = get_room(get_current_room());
  var objects = get_room_objects(room);
  var obj_i = 0;
  var obj_len = length(objects);
  while (obj_i <= (obj_len-1)) (
    var obj_pos = get_object_position(get(objects, obj_i));
    var obj_transform = get_object_transform(get(objects, obj_i));
    var obj_render = get_object_renderObject(get(objects, obj_i));
    var obj_mesh = get_render_object_mesh(obj_render);
    var obj_tex = get_render_object_texture(obj_render);
    var obj_shader = get_render_object_shader(obj_render);
    draw_object(obj_pos, obj_transform, obj_mesh, obj_tex, obj_shader, lights);
  );
);

var draw_player = fun lights: (Light Array) -> (
  var player = get_player(get_game());
  var player_transform = get_player_transform(player);
  var player_render = get_player_render_object(player);
  var player_mesh = get_render_object_mesh(player_render);
  var player_tex = get_render_object_texture(player_render);
  var player_shader = get_render_object_shader(player_render);
  draw_object(vec3(0.0,0.0,0.0), player_transform, player_mesh, player_tex, player_shader, lights);
);

var draw_scene = fun -> (
  var lights = get_room_lights(get_room(get_current_room()));
  draw_room(lights);
  draw_objects(lights);
  draw_player(lights);
);

render js<
  update();
  #draw
  draw_scene();
>
