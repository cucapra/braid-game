# This is the SCC preamble for WebGL programs. It includes the functions
# provided by the `glrt` runtime library.

# Sample assets to play with.
extern bunny: Mesh = "rt.bunny";
extern teapot: Mesh = "rt.teapot";

# Mesh asset wrangling.
extern mesh_indices: Mesh -> (Int3 Buffer) = "rt.mesh_indices";
extern mesh_positions: Mesh -> (Float3 Buffer) = "rt.mesh_positions";
extern mesh_normals: Mesh -> (Float3 Buffer) = "rt.mesh_normals";
extern mesh_size: Mesh -> Int = "rt.mesh_size";
extern mesh_count: Mesh -> Int = "rt.mesh_count";
extern mesh_texcoords: Mesh -> (Float2 Buffer) = "rt.mesh_texcoords";
extern mesh_tangents: Mesh -> (Float3 Buffer) = "rt.mesh_tangents";
extern draw_mesh: (Int3 Buffer) Int -> Void = "rt.draw_mesh";
extern draw_arrays: Int -> Void = "rt.draw_arrays";
extern array_buffer:
    (Int Buffer) -> (Int Array) |
    (Float Array) -> (Float Buffer) |
    (Float2 Array) -> (Float2 Buffer) |
    (Float3 Array) -> (Float3 Buffer) |
    (Float4 Array) -> (Float4 Buffer)
    = "rt.array_buffer";
extern element_buffer: (Int Array) -> (Int3 Buffer) = "rt.element_buffer";

# Matrix manipulation library.
extern mat4.create: -> Mat4 = "rt.mat4.create";
extern mat4.rotate: Mat4 Mat4 Float Vec3 -> Void = "rt.mat4.rotate";
extern mat4.rotateX: Mat4 Mat4 Float -> Void = "rt.mat4.rotateX";
extern mat4.rotateY: Mat4 Mat4 Float -> Void = "rt.mat4.rotateY";
extern mat4.rotateZ: Mat4 Mat4 Float -> Void = "rt.mat4.rotateZ";
extern mat4.scale: Mat4 Mat4 Vec3 -> Void = "rt.mat4.scale";
extern mat4.translate: Mat4 Mat4 Vec3 -> Void = "rt.mat4.translate";
extern mat4.fromTranslation: Mat4 Vec3 -> Void = "rt.mat4.fromTranslation";
extern mat4.transpose: Mat4 Mat4 -> Void = "rt.mat4.transpose";
extern mat4.scale: Mat4 Mat4 Vec3 -> Void = "rt.mat4.scale";
extern mat4.invert: Mat4 Mat4 -> Void = "rt.mat4.invert";
extern mat4.perspective: Mat4 Float Float Float Float -> Void
    = "rt.mat4.perspective";
extern mat4.lookAt: Mat4 Vec3 Vec3 Vec3 -> Void = "rt.mat4.lookAt";

# Get the camera position (in world space) from a view matrix.
extern eye: Mat4 -> Vec3 = "rt.eye";

# Assets: loading images and such.
extern load_obj: String -> Mesh = "rt.load_obj";
extern load_texture: String -> Texture = "rt.load_texture";
extern load_raw: String -> Mesh = "rt.load_raw";
extern load_image: String -> Image = "rt.load_image";
extern average: Image -> Float4 = "rt.average";

# Create a standard 2D texture from an image or a blank texture "from scratch."
extern texture: Image -> Texture | -> Texture = "rt.texture";
# Create a cube-map texture. The arguments are:
# [posx, negx, posy, negy, posz, negz]
extern cubeTexture:
    Image Image Image Image Image Image -> CubeTexture |
    -> CubeTexture
    = "rt.cubeTexture";

# Manage frame buffer objects.
extern createFramebuffer: -> Framebuffer = "rt.createFramebuffer";
extern framebufferTexture:
    Framebuffer Texture -> Void |
    Framebuffer CubeTexture Int -> Void
    = "rt.framebufferTexture";
extern bindFramebuffer: Framebuffer -> Void = "rt.bindFramebuffer";

# A framebuffer representing the content to be shown in the canvas
extern screenbuffer: Framebuffer = "rt.screenbuffer";

# Standard JavaScript functions.
extern Date.now: -> Float;
extern Math.sin: Float -> Float;
extern Math.cos: Float -> Float;

# Random numbers.
extern random.seed: -> Void = "rt.random.seed";
extern random.flip: -> Float = "rt.random.flip";
type Transform = Mat4 * Mat4 * Mat4 * Mat4 * Mat4; # Translation * Rx * Ry * Rx * Scale
# Collider = name * parameter * transform
# default: sphere: center at 0,0,0
# default: plane: center at 0,0,0, normal at 1,0,0, up at 0,1,0
type Collider = String * Float2 * Transform; # TODO: how to define isCollision function here
type Shader = String;
type RenderObject = Mesh * Texture * Shader;
type Light = Vec3 * Vec3 * Float; # Color * Position * Intensity
type Trigger = String * ( -> Bool) * ( -> Void); # name * condition * action
# Object = name * position * local_transform * render_obj * * collider * light array * triggers
type Object = String * Vec3 * Transform * RenderObject * Collider * (Light Array) * (Trigger Array);
type Inventory = String;
# Player = Room * Collider * Inventory Array * Height * RenderObject * Transform
type Player = String * Collider * (Inventory Array) * Float * RenderObject * Transform;
# Room = Name * Lights * Objects * size * texture * start_position * start_direction
type Room = String * (Light Array) * (Object Array) * Vec3 * Texture * Vec2 * Vec3;
# Game = starting_room * (Room Array * Player)
type Game = String * (Room Array) * Player;

var __translate = mat4();
var __rotateX = mat4();
var __rotateY = mat4();
var __rotateZ = mat4();
var __scale = mat4();
mat4.translate(__translate, __translate, vec3(0.0, 0.0, 0.0));
mat4.rotateX(__rotateX, __rotateX, 0.0);
mat4.rotateY(__rotateY, __rotateY, 0.0);
mat4.rotateZ(__rotateZ, __rotateZ, 0.0);
mat4.scale(__scale, __scale, vec3(1.0, 1.0, 1.0));

var __identity = (
    __translate,
    __rotateX,
    __rotateY,
    __rotateZ,
    __scale
);

var __wood = load_texture("wood1.png");

var __game = (
    "room1",
    # Room
    array(
        (
            "room1",
            # Lights
            array(
                (vec3(1.0, 1.0, 1.0), vec3(0.0, 6.0, 0.0), 5.0)
            ),
            # Objects
            array(
                (
                    # Name
                    "teapot",
                    # Position
                    vec3(0.0, 2.5, 10.0),
                    # Local Transform,
                    __identity,
                    # Render Object,
                    (teapot, __wood, "phong"),
                    # Collider
                    ("sphere", vec2(0.5, 0.5), __identity),
                    # Light
                    array{Light}(),
                    # Triggers
                    array{Trigger}()
                )
            ),
            # Size
            vec3(20.0, 6.0, 20.0),
            # Room Texture
            __wood,
            # Start Position,
            vec2(0.0, 0.0),
            # Start Direction
            vec3(0.0, 0.0, 1.0)
        )
    ),
    # Player
    (
        "room1",
        # Collider
        ("sphere", vec2(3.0, 3.0), __identity),
        # Inventory
        array{Inventory}(),
        # Height
        2.5,
        # RenderObject
        (teapot, __wood, "phong"),
        # Transform
        __identity
    )
);

var get_game = fun -> (
    __game
);

var get_current_room = fun -> (
    (__game).0
);

var get_rooms = fun -> (
    (__game).1
);

var get_room = fun name: String -> (
    var rooms = get_rooms();
    var i = 0;
    var room_picked = -1;
    while (i <= (length(rooms) - 1)) (
        var cur_room = get(rooms, i);
        if (equal((cur_room).0, name)) (
            room_picked = i;
            i = i + length(rooms);
        ) (i;);
        i = i + 1;
    );
    if (room_picked == (-1)) (
        1/0;
    ) (0;);
    get(rooms, room_picked)
);

var get_room_lights = fun room: Room -> (
    (room).1;
);

var get_room_light = fun room: Room index: Int -> (
    var lights = (room).1;
    get(lights, index);
);

var get_light_color = fun light: Light -> (
    (light).0;
);

var get_light_position = fun light: Light -> (
    (light).1;
);

var get_light_intensity = fun light: Light -> (
    (light).2;
);

var get_room_objects = fun room: Room -> (
    (room).2;
);

var get_room_object = fun room: Room name: String -> (
    var objects = get_room_objects(room);
    var i = 0;
    var object_picked = -1;
    while (i <= (length(objects) - 1)) (
        var cur_object = get(objects, i);
        if (equal((cur_object).0, name)) (
            object_picked = i;
            i = i + length(objects);
        ) (i;);
        i = i + 1;
    );
    if (object_picked == (-1)) (
        1/0;
    ) (0;);
    get(objects, object_picked);
);

var get_object_position = fun object: Object -> (
    (object).1;
);

var get_object_transform = fun object: Object -> (
    (object).2;
);

var get_object_renderObject = fun object: Object -> (
    (object).3;
);

var get_object_collider = fun object: Object -> (
    (object).4;
);

var get_object_lights = fun object: Object -> (
    (object).5;
);

var get_object_light = fun object: Object index: Int -> (
    get((object).5, index);
);

var get_object_triggers = fun object: Object -> (
    (object).6;
);

var get_transform_translation = fun transform: Transform -> (
    (transform).0;
);

var get_transform_rotationX = fun transform: Transform -> (
    (transform).1;
);

var get_transform_rotationY = fun transform: Transform -> (
    (transform).2;
);

var get_transform_rotationZ = fun transform: Transform -> (
    (transform).3;
);

var get_transform_scale = fun transform: Transform -> (
    (transform).4;
);

var get_collider_name = fun collider: Collider -> (
    (collider).0;
);

var get_collider_dimension = fun collider: Collider -> (
    (collider).1;
);

var get_collider_transform = fun collider: Collider -> (
    (collider).2;
);

var get_render_object_mesh = fun render_obj: RenderObject -> (
    (render_obj).0;
);

var get_render_object_texture = fun render_obj: RenderObject -> (
    (render_obj).1;
);

var get_render_object_shader = fun render_obj: RenderObject -> (
    (render_obj).2;
);

var get_trigger_name = fun trigger: Trigger -> (
    (trigger).0;
);

var get_trigger_condition = fun trigger: Trigger -> (
    (trigger).1;
);

var get_trigger_action = fun trigger: Trigger -> (
    (trigger).2;
);

var get_player = fun game: Game -> (
    (game).2;
);

var get_player_name = fun player : Player -> (
    (player).0;
);

var get_player_collider = fun player : Player -> (
    (player).1;
);

var get_player_inventory = fun player : Player -> (
    (player).2;
);

var get_player_item = fun player : Player index: Int -> (
    var inventory = (player).2;
    get(inventory, index);
);

var get_player_height = fun player : Player -> (
    (player).3;
);

var get_player_render_object = fun player : Player -> (
    (player).4;
);

var get_player_transform = fun player : Player -> (
    (player).5;
);

var get_room_name = fun room : Room -> (
    (room).0;
);

var get_room_size = fun room : Room -> (
    (room).3;
);

var get_room_texture = fun room : Room -> (
    (room).4;
);

var get_room_start_position = fun room : Room -> (
    (room).5;
);

var get_room_start_direction = fun room : Room -> (
    (room).6;
);

####################################################

var set_game = fun game: Game -> (
    __game = game;
);

var set_current_room = fun name: String -> (
    __game = name, get_rooms(), get_player(__game);
);

var set_rooms = fun rooms: (Room Array) -> (
    __game = get_current_room(), rooms, get_player(__game);
);

var set_room = fun name: String room: Room -> (
    var rooms = get_rooms();
    var i = 0;
    var room_picked = i;
    while (i <= (length(rooms) - 1)) (
        var cur_room = get(rooms, i);
        if (equal((cur_room).0, name)) (
            room_picked = i;
            i = i + length(rooms);
        ) (i);
        i = i + 1;
    );
    set(rooms, room_picked, room); # TODO: will set first elem if no such room name exists
);

var set_room_light = fun room: Room index: Int light: Light -> (
    var lights = (room).1;
    set(lights, index, light);
);

var set_light_color = fun light: Light color: Vec3 -> (
    var new_light = color, get_light_position(light), get_light_intensity(light);
    new_light;
);

var set_light_position = fun light: Light position: Vec3 -> (
    var new_light = get_light_color(light), position, get_light_intensity(light);
    new_light;
);

var set_light_intensity = fun light: Light intensity: Float -> (
    var new_light = get_light_color(light), get_light_position(light), intensity;
    new_light;
);

var set_room_objects = fun room: Room objects: (Object Array) -> (
    var new_room = get_room_name(room), ((room).1), objects, ((room).3);
);

var set_room_object = fun room: Room name: String object: Object -> (
    var objects = get_room_objects(room);
    var i = 0;
    var object_picked = -1;
    while (i <= (length(objects) - 1)) (
        var cur_object = get(objects, i);
        if (equal((cur_object).0, name)) (
            object_picked = i;
            i = i + length(objects);
        ) (i);
        i = i + 1;
    );
    if (i >= 0) (
        set(objects, object_picked, object);
        objects;
    )(
        objects;
    );
    room;
);

var set_object_position = fun object: Object position: Vec3 -> (
    var new_object = ((object).0), position, ((object).2), ((object).3),
    ((object).4), ((object).5), ((object).6);
    new_object;
);

var set_object_transform = fun object: Object transform: Transform -> (
    var new_object = ((object).0), get_object_position(object), transform,
    ((object).3), ((object).4), ((object).5), ((object).6);
    new_object;
);

var set_object_renderObject = fun object: Object render_obj: RenderObject -> (
    var new_object = ((object).0), get_object_position(object), get_object_transform(object),
      render_obj, ((object).4), ((object).5), ((object).6);
    new_object;
);

var set_object_collider = fun object:Object collider:Collider -> (
    var new_object = ((object).0), get_object_position(object), get_object_transform(object),
      get_object_renderObject(object), collider, ((object).5), ((object).6);
    new_object;
);

var set_object_light = fun object:Object light:Light -> (
    var new_object = ((object).0), get_object_position(object), get_object_transform(object),
      get_object_renderObject(object), get_object_collider(object), light, ((object).6);
    new_object;
);

var set_object_triggers = fun object:Object triggers: (Trigger Array) -> (
    var new_object = ((object).0), get_object_position(object), get_object_transform(object),
      get_object_renderObject(object), get_object_collider(object), get_object_lights(object), triggers;
    new_object;
);

var set_transform_translation = fun transform:Transform translation:Mat4 -> (
    var new_transform = translation, ((transform).1), ((transform).2), ((transform).3), ((transform).4);
    new_transform;
);

var set_transform_rotationX = fun transform:Transform rx:Mat4 -> (
    var new_transform = get_transform_translation(transform), rx, ((transform).2), ((transform).3), ((transform).4);
    new_transform;
);

var set_transform_rotationY = fun transform:Transform ry:Mat4 -> (
    var new_transform = ((transform).0), ((transform).1), ry, ((transform).3), ((transform).4);
    new_transform;
);

var set_transform_rotationZ = fun transform:Transform rz:Mat4 -> (
    var new_transform = ((transform).0), ((transform).1), ((transform).2), rz, ((transform).4);
    new_transform;
);

var set_transform_scale = fun transform:Transform scale:Mat4 -> (
    var new_transform = ((transform).0), ((transform).1), ((transform).2), ((transform).3), scale;
    new_transform;
);

var set_collider_name = fun collider: Collider name: String -> (
    var new_collider = name, ((collider).1), ((collider).2);
    new_collider;
);

var set_collider_dimension = fun collider: Collider dimension: Float2 -> (
    var new_collider = ((collider).0), dimension, ((collider).2);
    new_collider;
);

var set_collider_transform = fun collider: Collider transform: Transform -> (
    var new_collider = ((collider).0), ((collider).1), transform;
    new_collider;
);

var set_render_object_mesh = fun render_obj: RenderObject mesh: Mesh -> (
    mesh, ((render_obj).1), ((render_obj).2);
);

var set_render_object_texture = fun render_obj: RenderObject texture: Texture -> (
    ((render_obj).0), texture, ((render_obj).2);
);

var set_render_object_shader = fun render_obj: RenderObject shader: Shader -> (
    ((render_obj).0), ((render_obj).1), shader;
);

var set_trigger_name = fun trigger:Trigger name: String -> (
    name, ((trigger).1), ((trigger).2);
);

var set_trigger_condition = fun trigger: Trigger condition: (-> Bool) -> (
    ((trigger).0), condition, ((trigger).2);
);

var set_trigger_action = fun trigger:Trigger action: (-> Void) -> (
    ((trigger).0), ((trigger).1), action;
);

var set_player = fun game: Game player: Player -> (
    __game = ((game).0), ((game).1), player;
);

var set_player_name = fun player : Player name: String -> (
    var new_player = name, ((player).1), ((player).2), ((player).3), ((player).4), ((player).5);
    set_player(get_game(), new_player);
);

var set_player_collider = fun player : Player collider: Collider -> (
    var new_player = ((player).0), collider, ((player).2), ((player).3), ((player).4), ((player).5);
    set_player(get_game(), new_player);
);

var set_player_inventory = fun player:Player inv:(Inventory Array) -> (
    var new_player = ((player).0), ((player).1), inv, ((player).3), ((player).4), ((player).5);
    set_player(get_game(), new_player);
);

var set_player_item = fun player : Player index: Int inv_item : Inventory -> (
    var inventory = ((player).2);
    set(inventory, index, inv_item);
);

var set_player_height = fun player:Player height: Float -> (
    var new_player = ((player).0), ((player).1), ((player).2), height, ((player).4), ((player).5);
    set_player(get_game(), new_player);
);

var set_player_render_object = fun player : Player render_obj: RenderObject -> (
    var new_player = ((player).0), ((player).1), ((player).2), ((player).3), render_obj, ((player).5);
    set_player(get_game(), new_player);
);

var set_player_transform = fun player: Player transform: Transform -> (
    var new_player = ((player).0), ((player).1), ((player).2), ((player).3), ((player).4), transform;
    set_player(get_game(), new_player);
);
# Room = Name * Lights * Objects * size * texture * start_position * start_direction
var set_room_name = fun room : Room name: String -> (
    name, ((room).1), ((room).2), ((room).3), ((room).4), ((room).5), ((room).6);
);

var set_room_size = fun room : Room size: Vec3 -> (
    ((room).0), ((room).1), ((room).2), size ,((room).4), ((room).5), ((room).6);
);

var set_room_texture = fun room : Room texture: Texture -> (
    ((room).0), ((room).1), ((room).2), ((room).3), texture, ((room).5), ((room).6);
);

var set_room_start_position = fun room : Room start_pos: Vec2 -> (
    ((room).0), ((room).1), ((room).2), ((room).3), ((room).4), start_pos, ((room).6);
);

var set_room_start_direction = fun room : Room start_dir: Vec3 -> (
    ((room).0), ((room).1), ((room).2), ((room).3), ((room).4), ((room).5), start_dir;
);
type GameObj = Float3 * Float; # a spherical bounding box
type Plane = Float3 * Float3; # origin and normal, normal points *inside*

############################ obj ############################

def make_object (pos: Float3, radius: Float) (
	pos, radius;
);

def get_obj_pos (obj: GameObj) (
	(obj).0;
);

def get_obj_radius (obj: GameObj) (
	(obj).1;
);

def check_collision(o1: GameObj, o2: GameObj) (
	var dist = get_obj_pos(o1) - get_obj_pos(o2);
	dot(dist, dist) <= (get_obj_radius(o1) + get_obj_radius(o2));
);

############################ plane ###########################
def make_plane (o: Float3, n: Float3) (
	o, normalize(n);
);

def plane_from_trans (m: Mat4) (
	var o = vec3((m * vec4(0, 0, 0, 1)));
	var n = normalize(vec3((m * vec4(0, 0, -1, 0))));
	make_plane(o, n);
);

def get_plane_origin (obj: Plane) (
	(obj).0;
);

def get_plane_normal (obj: Plane) (
	(obj).1;
);

# normal vector of plane is unit vector
def check_collision_geom(o: GameObj, p: Plane) (
	var dist = dot(get_obj_pos(o)-get_plane_origin(p), get_plane_normal(p));
	(dist*dist) <= (get_obj_radius(o)*get_obj_radius(o));
);

var bot_collision_radius = 5.0; # collider size of the robot itself.
extern camera.update : String -> Void = "rt.camera.updateCam";
extern camera.getViewMatrix : Mat4 -> Void = "rt.camera.getViewM";
extern camera.getProjMatrix : Mat4 Float Float -> Void = "rt.camera.getProjM";
extern camera.simulateControl : Float3 String -> Void = "rt.camera.simCtrl";
extern camera.getEye : -> Float3 = "rt.camera.getEyePos";
extern control.isOn : String -> Bool = "rt.control.isOn";
extern control.control_names : String Array = "rt.control.control_names";
extern print : Any -> Void = "console.log";
extern vec4.transformMat4 : Float4 Float4 Mat4 -> Void;
extern rt.drawWidth: Float;
extern rt.drawHeight: Float;
extern get_player_cmds: -> (String Array) = "rt.control.get_cmds";

var action_button = false;

var get_all_triggers = fun -> (
  var cur_room_name = get_current_room();
  var cur_room = get_room(cur_room_name);
  var objects = get_room_objects(cur_room);
  var obj_length = length(objects);
  var i = 0;
  var triggers = array{Trigger}();
  while (i <= (obj_length-1)) (
    var obj = get(objects, i);
    var obj_triggers = get_object_triggers(obj);
    var trigger_length = length(obj_triggers);
    var j = 0;
    while (j <= (trigger_length-1)) (
      push(triggers, get(obj_triggers, j));
      j = j+1;
    );
    i = i+1;
  );
  triggers;
);


# return whether a trigger is activated and what the trigger is
# multiple triggers can happen during one command.
def simulate_trigger(cmd: String) (#: Bool*(Trigger Array) (
  if (equal(cmd,"e")) (
    action_button = true;0;
  )(0);
  # check all triggers in this room
  var all_triggers = get_all_triggers();
  var trigger_num = length(all_triggers);
  var activated = array{Trigger}();
  var i = 0;
  while (i <= (trigger_num-1)) (
    var trigger = get(all_triggers, i);
    var cond = get_trigger_condition(trigger);
    if (cond()) (
      push(activated, trigger);
      0;
    )(0;);
    i = i + 1;
  );
  activated;
);

def apply_transform_pos(trans: Transform, pos: Vec3) (
  var t = get_transform_translation(trans);
  var rx = get_transform_rotationX(trans);
  var ry = get_transform_rotationY(trans);
  var rz = get_transform_rotationZ(trans);
  var s = get_transform_scale(trans);
  var hpos = vec4(pos, 1.0);
  hpos = t*rx*ry*rz*s*hpos;
  vec3(hpos);
);

def apply_transform_dir(trans: Transform, pos: Vec3) (
  var t = get_transform_translation(trans);
  var rx = get_transform_rotationX(trans);
  var ry = get_transform_rotationY(trans);
  var rz = get_transform_rotationZ(trans);
  var s = get_transform_scale(trans);
  var hpos = vec4(pos, 0.0);
  hpos = t*rx*ry*rz*s*hpos;
  vec3(hpos);
);

def get_sphere_collider_attr(collider: Collider) (
  #get pos*radius
  var radius = swizzle(get_collider_dimension(collider), "x");
  var trans = get_collider_transform(collider);
  apply_transform_pos(trans, vec3(0.0,0.0,0.0)), radius
);

def get_plane_collider_attr(collider: Collider) (
  #get pos*normal*tangent1*tangent2*width*height
  var w = swizzle(get_collider_dimension(collider), "x");
  var h = swizzle(get_collider_dimension(collider), "y");
  var trans = get_collider_transform(collider);
  var pos = apply_transform_pos(trans, vec3(0.0,0.0,0.0));
  var n = apply_transform_dir(trans, vec3(0.0,0.0,-1.0));
  var t1 = apply_transform_dir(trans, vec3(1.0,0.0,0.0));
  var t2 = apply_transform_dir(trans, vec3(0.0,1.0,0.0));
  pos,n,t1,t2,w,h
);

#TODO handle other kind of colliders
def collision_test_pair(obj1: Collider, obj2: Collider) (
  var collider_name1 = get_collider_name(obj1);
  var collider_name2 = get_collider_name(obj2);
  if (equal(collider_name1, "sphere")) (
    if (equal(collider_name2, "sphere")) (
      false
    )(
      false
    )
  ) (
    if (equal(collider_name2, "sphere")) (
      false
    )(
      false
    )
  )
);

def new_collider_position(collider: Collider, pos: Vec3) (
  var transform = get_collider_transform(collider);
  var new_translate = mat4();
  mat4.translate(new_translate, new_translate, pos);
  var new_transform = set_transform_translation(transform, new_translate);
  set_collider_transform(collider, new_transform)
);

def set_player_position(pos: Vec3) (
  var player = get_player(get_game());
  var transform = get_player_transform(player);
  var newTranslation = mat4.create();
  mat4.translate(newTranslation, newTranslation, pos);
  transform = set_transform_translation(transform, newTranslation);
  set_player_transform(player, transform);
);

def collision_test(obj: Collider) (
  # test if obj collide with any colliders in this room
  var cur_room_name = get_current_room();
  var cur_room = get_room(cur_room_name);
  var objects = get_room_objects(cur_room);
  var obj_length = length(objects);
  var i = 0;
  var has_collision = false;
  while (i <= (obj_length-1)) (
    var collider = get_object_collider(get(objects, i));
    if (collision_test_pair(obj, collider)) (
      has_collision = true;
    )(has_collision);
    i = i+1;
  );
  has_collision;
);


# return whether move is successful and what is the new player position
def simulate_player_move(cmd: String) (#: Bool * Vec3 (
  var target = vec3(0.0,0.0,0.0);
  camera.simulateControl(target, cmd);
  var player_collider = get_player_collider(get_player(get_game()));
  var target_collider = new_collider_position(player_collider, target);
  collision_test(target_collider), target;
);

def simulate_player_cmds(cmds: String Array) (
  var array_len = length(cmds);
  var i = 0;
  var effective_cmds = array{String}();
  var effective_triggers = array{Trigger}();
  while (i <= (array_len-1)) (
    var cmd = get(cmds, i);
    var move_record = simulate_player_move(cmd);
    if ((move_record).0) (
      push(effective_cmds, cmd);0
    ) (0);
    var game_copy = get_game();
    set_player_position((move_record).1); #TODO, actually should update player
    set_game(game_copy);
    var trigger_record = simulate_trigger(cmd);
    var num_triggers = length(trigger_record);
    if (num_triggers >= 1) (
      var res_length = length(trigger_record);
      var j = 0;
      while (j <= (res_length-1)) (
        push(effective_triggers, get(trigger_record, j));
        j = j+1;
      );0
    ) (0);
    i = i + 1;
  );
  effective_cmds, effective_triggers;
);

var resolve_player_action = fun -> (
  var cmd = get_player_cmds();
  var simulation_record = simulate_player_cmds(cmd);
  simulation_record;
);


def resolve_movement(cmd: (String Array)) (
  var cmd_length = length(cmd);
  var i = 0;
  while (i <= (cmd_length-1)) (
    var c = get(cmd, i);
    camera.update(c);
    i = i+1;
  );
  set_player_position(camera.getEye());
);

def resolve_trigger(triggers: (Trigger Array)) (
  var trigger_length = length(triggers);
  var i = 0;
  while (i <= (trigger_length-1)) (
    var t = get(triggers, i);
    var action = get_trigger_action(t);
    action();
  );
);

def resolve_interaction(simulation_record: (String Array) * (Trigger Array)) (
  resolve_movement((simulation_record).0);
  resolve_trigger((simulation_record).1);
);


var update = fun -> (
  var sim_record = resolve_player_action();
  resolve_interaction(sim_record);
);
